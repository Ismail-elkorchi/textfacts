import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const ROOT = process.cwd();
const OUT_DIR = path.join(ROOT, "docs", "bench");
const REPORT_PATH = path.join(OUT_DIR, "bench-report.v1.json");
const MD_PATH = path.join(OUT_DIR, "bench-report.md");

function mulberry32(seed) {
  let state = seed >>> 0;
  return () => {
    state += 0x6d2b79f5;
    let mixed = Math.imul(state ^ (state >>> 15), state | 1);
    mixed ^= mixed + Math.imul(mixed ^ (mixed >>> 7), mixed | 61);
    return ((mixed ^ (mixed >>> 14)) >>> 0) / 4294967296;
  };
}

function generateText(seed, targetLength) {
  const rand = mulberry32(seed);
  const fragments = [
    "Deterministic ",
    "textfacts ",
    "Unicode ",
    "Î£", // Greek
    "æ¼¢å­—", // CJK
    "Ù…Ø±Ø­Ø¨Ø§", // Arabic
    "à¤¹à¤¿à¤¨à¥à¤¦à¥€", // Devanagari
    "e\u0301", // combining
    "ğŸ™‚", // emoji
    "ğŸ‡ºğŸ‡¸", // flag
    "â€”", // em dash
    "â€¢", // bullet
  ];
  const separators = [" ", " ", "\n", ", ", ". ", " â€” "];
  let out = "";
  while (out.length < targetLength) {
    const frag = fragments[Math.floor(rand() * fragments.length)];
    const sep = separators[Math.floor(rand() * separators.length)];
    out += frag + sep;
  }
  return out.slice(0, targetLength);
}

function mutateText(text, seed) {
  const rand = mulberry32(seed);
  const chars = text.split("");
  for (let charIndex = 0; charIndex < chars.length; charIndex += 97) {
    if (rand() > 0.7) {
      chars[charIndex] = chars[charIndex] === "a" ? "b" : "a";
    }
  }
  return chars.join("");
}

function nowMs() {
  return Number(process.hrtime.bigint()) / 1e6;
}

function measure(id, iterations, fn) {
  const start = nowMs();
  let lastResult;
  for (let iterationIndex = 0; iterationIndex < iterations; iterationIndex += 1) {
    lastResult = fn();
  }
  const elapsed = nowMs() - start;
  const msPerOp = elapsed / iterations;
  const opsPerSec = msPerOp > 0 ? 1000 / msPerOp : 0;
  return { id, iterations, msPerOp, opsPerSec, sample: lastResult };
}

function renderMarkdown(report) {
  const rows = report.benchmarks.map(
    (bench) =>
      `| ${bench.id} | ${bench.iterations} | ${bench.msPerOp.toFixed(3)} | ${bench.opsPerSec.toFixed(2)} |`,
  );

  return [
    "# Bench Report",
    "",
    `_Generated by \`npm run bench:run\`._`,
    "",
    `- Generated at: ${report.generatedAt}`,
    `- Node: ${report.environment.node}`,
    `- Platform: ${report.environment.platform} (${report.environment.arch})`,
    `- Seed: ${report.seed}`,
    "",
    "| Benchmark | Iterations | ms/op | ops/sec |",
    "| --- | --- | --- | --- |",
    ...rows,
    "",
  ].join("\n");
}

async function main() {
  const distUrl = new URL("../../dist/src/all/mod.js", import.meta.url);
  const distPath = fileURLToPath(distUrl);
  await fs.access(distPath).catch(() => {
    throw new Error("dist/src/all/mod.js not found. Run `npm run build` first.");
  });

  const textfacts = await import(distUrl.href);

  const seed = 1337;
  const baseText = generateText(seed, 24000);
  const altText = mutateText(baseText, seed + 1);

  const benches = [];

  benches.push(
    measure("segment-grapheme", 30, () => {
      let count = 0;
      for (const _ of textfacts.segmentGraphemes(baseText)) count += 1;
      return count;
    }),
  );

  benches.push(
    measure("segment-uax29-wb", 30, () => {
      let count = 0;
      for (const _ of textfacts.segmentWordsUAX29(baseText)) count += 1;
      return count;
    }),
  );

  benches.push(
    measure("segment-sentence-boundary", 30, () => {
      let count = 0;
      for (const _ of textfacts.segmentSentencesUAX29(baseText)) count += 1;
      return count;
    }),
  );

  benches.push(measure("normalize-nfc", 40, () => textfacts.normalize(baseText, "NFC")));

  benches.push(measure("normalize-nfkc", 40, () => textfacts.normalize(baseText, "NFKC")));

  benches.push(measure("idna-uts46-to-ascii", 200, () => textfacts.uts46ToAscii("exÃ¤mple.test")));

  benches.push(measure("collation-sort-key", 100, () => textfacts.ucaSortKeyBytes("cafÃ©")));

  benches.push(measure("diff-text", 50, () => textfacts.diffText(baseText, altText, {})));

  benches.push(
    measure("winnowing-fingerprints", 30, () =>
      textfacts.winnowingFingerprints(baseText, { k: 5, window: 4, dedupe: "min" }),
    ),
  );

  const report = {
    v: 1,
    generatedAt: new Date().toISOString(),
    seed,
    environment: {
      node: process.version,
      platform: process.platform,
      arch: process.arch,
    },
    benchmarks: benches.map((bench) => ({
      id: bench.id,
      iterations: bench.iterations,
      msPerOp: bench.msPerOp,
      opsPerSec: bench.opsPerSec,
    })),
  };

  await fs.mkdir(OUT_DIR, { recursive: true });
  await fs.writeFile(REPORT_PATH, JSON.stringify(report, null, 2) + "\n", "utf8");
  await fs.writeFile(MD_PATH, renderMarkdown(report), "utf8");

  console.log(`bench:run summary: benchmarks=${report.benchmarks.length}`);
}

await main();
